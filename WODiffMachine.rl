//
// WODiffMachine.m/WODiffMachine.rl
// gdiff
//
// Created by Wincent Colaiuta on 21 September 2007.
// Copyright 2007 Wincent Colaiuta.

// --------------------------------------------------------------------------------------------------------- //
// NOTE: The file WODiffMachine.m is auto-generated by Ragel; do not edit it: edit WODiffMachine.rl instead. //
// --------------------------------------------------------------------------------------------------------- //

%%{
    machine WODiffMachine;

    # initializes buffer for incrementally accumulating characters in quoted paths (which may contain escape sequences)
    action prepare_buffer               { buffer = [NSMutableString string]; }

    # records the position of the current character
    # used for simple captures of ASCII text such as blob ids, numeric escapes and unquoted paths
    action set_mark                     { mark = p; }

    # initializes the buffer from the block of memory previously marked with set_mark up to the current location
    action copy_to_buffer
    {
        buffer = [[NSString alloc] initWithBytesNoCopy:mark length:(p - mark) encoding:NSASCIIStringEncoding freeWhenDone:NO];
    }

    # appends the last-seen char to the current filename buffer (useful for parsing escape sequences)
    action append_tab                   { [buffer appendString:@"\t"]; }
    action append_linefeed              { [buffer appendString:@"\n"]; }
    action append_quote                 { [buffer appendString:@"\""]; }
    action append_backslash             { [buffer appendString:@"\\"]; }
    action append_current_char          { [buffer appendFormat:@"%c", *p];}

    # At this stage this code is little more than a proof-of-concept showing that numeric escapes can be scanned.
    # In reality appending the bytes one at a time won't work because the buffer presumably uses NSString's native encoding
    # (UTF-16) whereas the bytes could theoretically be in any platform-specific encoding (on my machine they're in UTF-8).
    # Note that the following code doesn't yield the right results even on my own system; I'd need to scan all of the escapes
    # in a given sequence at once, initialize a new NSString based on UTF-8 encoding from them, and only then append them to
    # the buffer. The best way to do this is probably to make the buffer an NSMutableData object and accumulate raw bytes.
    # Only once the entire path is scanned will I try to convert that.
    action append_numeric_escape
    {
        // note that the atoi() call here could be replaced with an "all transitions" action and some bitwise shift arithmetic
        [buffer appendFormat:@"%c", atoi(mark)];
    }

    # for capturing line ranges
    action clear_range_pointers         { location_pointer = length_pointer = NULL; }
    action store_location_pointer       { location_pointer = p; }
    action store_length_pointer         { length_pointer = p; }

    # for storing chunk boundaries based on captured ranges
    action store_from_range
    {
        // note that the atoi() call here could be replaced with an "all transitions" action and some bitwise shift arithmetic
        from_file_chunk_start = atoi(location_pointer);
    }

    action store_to_range
    {
        // note that the atoi() call here could be replaced with an "all transitions" action and some bitwise shift arithmetic
        to_file_chunk_start = atoi(location_pointer);
    }

    # called when starting a new file, finalizes any existing changes and files
    action start_file
    {
        if (change) [file appendChange:change];
        change = nil;
        if (file) [diff appendFile:file];
        file = [WOFile file];
    }

    action store_from_spec  { [file setFromPath:buffer]; }
    action store_to_spec    { [file setToPath:buffer]; }
    action store_from_hash  { [file setFromHash:buffer]; }
    action store_to_hash    { [file setToHash:buffer]; }

    # called on entering a new chunk, finalizes any existing changes
    action reset_line_counters
    {
        if (change)
        {
            [file appendChange:change];
            change  = nil;
        }
        from_cursor = from_file_chunk_start > 0 ? from_file_chunk_start - 1 : 0;
        to_cursor   = to_file_chunk_start > 0 ? to_file_chunk_start - 1 : 0;
    }

    # called on scanning a line of context (neither addition nor removal), finalizes any existing change
    action record_context_line
    {
        if (change)
        {
            [file appendChange:change];
            change = nil;
        }
        from_cursor++;
        to_cursor++;
    }

    # called on scanning a deletion line, starts a new change if necessary
    action record_deletion_line
    {
        from_cursor++;
        if (!change)
            change = [WOChange changeWithDeletionAtLine:from_cursor];
        else
            [change addDeletionAtLine:from_cursor];
    }

    # called on scanning an insertion line, starts a new change if necessary
    action record_insertion_line
    {
        to_cursor++;
        if (!change)
            change = [WOChange changeWithInsertionAtLine:to_cursor];
        else
            [change addInsertionAtLine:to_cursor];
    }

    # machine order here is largely determined by Ragel (no forward references allowed)
    linefeed                  = "\n" @{ line_idx++; };
    sp                        = " " ;

    git_diff_header           = "diff --git" sp (any - linefeed)+ linefeed ;

    octal_digit               = "0".."7" ;
    mode                      = octal_digit octal_digit octal_digit octal_digit octal_digit octal_digit ;

    hex_digit                 = "0".."9" | "a".."f" ;
    hash                      = hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit ;

    # start with basic set of possible headers seen in samples
    # later support others in git.git/Documentation/diff-format.txt if necessary
    extended_header           = "deleted file mode" sp mode linefeed
                              | "new file mode" sp mode linefeed
                              | "index" sp %set_mark hash %copy_to_buffer %store_from_hash ".."
                                           %set_mark hash %copy_to_buffer %store_to_hash (sp mode)? linefeed ;

    dev_null                  = "/dev/null" @{ buffer = @"/dev/null"; };

    numeric_escape            = "\\" %set_mark digit digit digit @append_numeric_escape ;
    tab_escape                = "\\t" @append_tab ;
    linefeed_escape           = "\\n" @append_linefeed ;
    quote_escape              = "\\\"" @append_quote ;
    backslash_escape          = "\\\\" @append_backslash ;
    escape                    = numeric_escape | tab_escape | linefeed_escape | quote_escape | backslash_escape ;

    # must accumulate character by character in order to correctly handle escape sequences
    quoted_from_filespec      = '"a/' %prepare_buffer (escape | [^"\\\n] $append_current_char )+ '"' ;

    # in unquoted case can just record start of string
    unquoted_from_filespec    = "a/" %set_mark (any - linefeed)+ %copy_to_buffer ;
    from_filespec             = quoted_from_filespec | unquoted_from_filespec | dev_null ;

    quoted_to_filespec        = '"b/' %prepare_buffer (escape | [^"\\\n] $append_current_char )+ '"' ;
    unquoted_to_filespec      = "b/" %set_mark (any - linefeed)+ %copy_to_buffer ;
    to_filespec               = quoted_to_filespec | unquoted_to_filespec | dev_null ;

    from_spec                 = "---" sp from_filespec linefeed %store_from_spec ;
    to_spec                   = "+++" sp to_filespec linefeed %store_to_spec ;

    from_range                = "-" ;
    to_range                  = "+" ;
    range                     = digit+ >store_location_pointer ("," digit+ >store_length_pointer)? ;
    range_spec                = "@@" sp >clear_range_pointers
                              . from_range range %store_from_range sp
                              . to_range range %store_to_range sp "@@" (any - linefeed)* linefeed ;

    context_line              = sp >record_context_line (any - linefeed)* linefeed ;
    deletion_line             = "-" >record_deletion_line (any - linefeed)* linefeed ;
    insertion_line            = "+" >record_insertion_line (any - linefeed)* linefeed ;
    newline_warning           = "\\ No newline at end of file" linefeed? ;

    chunk                     = range_spec %reset_line_counters
                              . (context_line | deletion_line | insertion_line | newline_warning)+ ;
    file_block                = git_diff_header %start_file
                              . extended_header+
                              . from_spec
                              . to_spec
                              . chunk+;

    main                      := file_block+ ;

}%%

// class header
#import "WODiffMachine.h"

// project headers
#import "WOChange.h"
#import "WODiff.h"
#import "WOFile.h"

// Ragel static data
%% write data;

@implementation WODiffMachine

+ (WODiffMachine *)diffMachine
{
    return [[self alloc] init];
}

- (WODiff *)parseDiffData:(NSData *)inData
{
    int     cs;                                     // current state; initially WODiffMachine_start
    char    *p          = (char *)[inData bytes];   // data pointer
    char    *pe         = p + [inData length];      // data end pointer
    int     line_idx    = 0;
    diff = [WODiff diff];
    %% write init;
    %% write exec;

    // finalize and dangling changes/files
    if (change) [file appendChange:change];
    if (file)   [diff appendFile:file];
    NSLog(@"debug info:\n %@", diff);
    NSLog(@"consumed all input? %d", p == pe);
    return (p == pe) ? diff : nil;                  // return nil if did not consume all the input
}

@end
