//
// WODiffMachine.m/WODiffMachine.rl
// gdiff
//
// Created by Wincent Colaiuta on 21 September 2007.
// Copyright 2007 Wincent Colaiuta.
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// --------------------------------------------------------------------------------------------------------- //
// NOTE: The file WODiffMachine.m is auto-generated by Ragel; do not edit it: edit WODiffMachine.rl instead. //
// --------------------------------------------------------------------------------------------------------- //

%%{
    machine WODiffMachine;

    # records the position of the current character
    # used for simple captures of ASCII text such as blob ids, numeric escapes and unquoted paths
    action set_mark                     { mark = p; }

    # initializes the buffer from the block of memory previously marked with set_mark up to the current location
    action copy_to_buffer
    {
        buffer = [[NSString alloc] initWithBytesNoCopy:mark length:(p - mark) encoding:NSASCIIStringEncoding freeWhenDone:NO];
    }

    # for capturing line ranges
    action clear_range_counters         { from_file_chunk_start = to_file_chunk_start = 0; }

    # for storing chunk boundaries based on captured ranges
    action update_from_range            { from_file_chunk_start = from_file_chunk_start * 10 + (*p - 48); }
    action update_to_range              { to_file_chunk_start = to_file_chunk_start * 10 + (*p - 48); }

    # called when starting a new file, finalizes any existing changes and files
    action start_file
    {
        if (change) [file appendChange:change];
        change = nil;
        if (file) [diff appendFile:file];
        file = [WOFile file];
    }

    action store_from_spec  { [file setFromPath:buffer]; }
    action store_to_spec    { [file setToPath:buffer]; }
    action store_from_hash  { [file setFromHash:buffer]; }
    action store_to_hash    { [file setToHash:buffer]; }

    # called on entering a new chunk, finalizes any existing changes
    action reset_line_counters
    {
        if (change)
        {
            [file appendChange:change];
            change  = nil;
        }
        from_cursor = from_file_chunk_start > 0 ? from_file_chunk_start - 1 : 0;
        to_cursor   = to_file_chunk_start > 0 ? to_file_chunk_start - 1 : 0;
    }

    # called on scanning a line of context (neither addition nor removal), finalizes any existing change
    action record_context_line
    {
        if (change)
        {
            [file appendChange:change];
            change = nil;
        }
        from_cursor++;
        to_cursor++;
    }

    # called on scanning a deletion line, starts a new change if necessary
    action record_deletion_line
    {
        from_cursor++;
        if (!change)
            change = [WOChange changeWithDeletionAtLine:from_cursor];
        else
            [change addDeletionAtLine:from_cursor];
    }

    # called on scanning an insertion line, starts a new change if necessary
    action record_insertion_line
    {
        to_cursor++;
        if (!change)
            change = [WOChange changeWithInsertionAtLine:to_cursor];
        else
            [change addInsertionAtLine:to_cursor];
    }

    # machine order here is largely determined by Ragel (no forward references allowed)
    linefeed                  = "\n" @{ line_idx++; };
    sp                        = " " ;

    git_diff_header           = "diff --git" sp (any - linefeed)+ linefeed ;

    octal_digit               = "0".."7" ;
    mode                      = octal_digit octal_digit octal_digit octal_digit octal_digit octal_digit ;

    hex_digit                 = "0".."9" | "a".."f" ;
    hash                      = hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit ;

    # start with basic set of possible headers seen in samples
    # later support others in git.git/Documentation/diff-format.txt if necessary
    extended_header           = "deleted file mode" sp mode linefeed
                              | "new file mode" sp mode linefeed
                              | "index" sp %set_mark hash %copy_to_buffer %store_from_hash ".."
                                           %set_mark hash %copy_to_buffer %store_to_hash (sp mode)? linefeed ;

    dev_null                  = "/dev/null" @{ buffer = @"/dev/null"; };

    numeric_escape            = "\\" digit digit digit ;
    tab_escape                = "\\t" ;
    linefeed_escape           = "\\n" ;
    quote_escape              = "\\\"" ;
    backslash_escape          = "\\\\" ;
    escape                    = numeric_escape | tab_escape | linefeed_escape | quote_escape | backslash_escape ;

    # TODO: add a flag to WOFile to indicate whether a path contains escape sequences (just like Git uses quotes for that purpose)
    quoted_from_filespec      = '"a/' %set_mark (escape | [^"\\\n])+ %copy_to_buffer '"' ;
    unquoted_from_filespec    = "a/" %set_mark (any - linefeed)+ %copy_to_buffer ;
    from_filespec             = quoted_from_filespec | unquoted_from_filespec | dev_null ;

    quoted_to_filespec        = '"b/' %set_mark (escape | [^"\\\n])+ %copy_to_buffer '"' ;
    unquoted_to_filespec      = "b/" %set_mark (any - linefeed)+ %copy_to_buffer ;
    to_filespec               = quoted_to_filespec | unquoted_to_filespec | dev_null ;

    from_spec                 = "---" sp from_filespec linefeed %store_from_spec ;
    to_spec                   = "+++" sp to_filespec linefeed %store_to_spec ;

    from_range                = "-" digit+ $update_from_range ("," digit+)? ;
    to_range                  = "+" digit+ $update_to_range ("," digit+)? ;
    range_spec                = "@@" sp >clear_range_counters from_range sp to_range sp "@@" (any - linefeed)* linefeed ;

    context_line              = sp >record_context_line (any - linefeed)* linefeed ;
    deletion_line             = "-" >record_deletion_line (any - linefeed)* linefeed ;
    insertion_line            = "+" >record_insertion_line (any - linefeed)* linefeed ;
    newline_warning           = "\\ No newline at end of file" linefeed? ;

    chunk                     = range_spec %reset_line_counters
                              . (context_line | deletion_line | insertion_line | newline_warning)+ ;
    file_block                = git_diff_header %start_file
                              . extended_header+
                              . from_spec
                              . to_spec
                              . chunk+;

    # skip over commit messages, email headers, and patch preambles, stopping on seeing first "diff --git" in column 0
    preamble_line             = ((any - linefeed)* - "diff --git") linefeed;
    main                      := preamble_line* file_block+ ;

}%%

// class header
#import "WODiffMachine.h"

// project headers
#import "WOChange.h"
#import "WODiff.h"
#import "WOFile.h"

// Ragel static data
%% write data;

@implementation WODiffMachine

+ (WODiffMachine *)diffMachine
{
    return [[self alloc] init];
}

- (WODiff *)parseDiffData:(NSData *)inData
{
    int     cs;                                     // current state; initially WODiffMachine_start
    char    *p          = (char *)[inData bytes];   // data pointer
    char    *pe         = p + [inData length];      // data end pointer
    int     line_idx    = 1;                        // start counting lines from line 1
    diff = [WODiff diff];
    %% write init;
    %% write exec;

    // finalize and dangling changes/files
    if (change) [file appendChange:change];
    if (file)   [diff appendFile:file];
    NSLog(@"debug info:\n %@", diff);

    if (p != pe)
    {
        NSLog(@"error: parse failure on line %d", line_idx);
        diff = nil; // return nil if did not consume all the input
    }
    return diff;
}

@end
